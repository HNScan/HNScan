{"version":3,"sources":["../src/mapDataUsingRowHeightIndex.js"],"names":["unmappedRows","rowHeightIndex","config","tableWidth","length","mappedRows","map","cells","index0","rowHeight","_","times","Array","fill","forEach","value","index1","chunkedValue","columns","wrapWord","width","part","index2","flatten"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;;;AAEA;;;;;;oCAMgBA,Y,EAAcC,c,EAAgBC,M,KAAW;AACvD,QAAMC,UAAU,GAAGH,YAAY,CAAC,CAAD,CAAZ,CAAgBI,MAAnC;AAEA,QAAMC,UAAU,GAAGL,YAAY,CAACM,GAAb,CAAiB,CAACC,KAAD,EAAQC,MAAR,KAAmB;AACrD,UAAMC,SAAS,GAAGC,gBAAEC,KAAF,CAAQV,cAAc,CAACO,MAAD,CAAtB,EAAgC,MAAM;AACtD,aAAO,IAAII,KAAJ,CAAUT,UAAV,EAAsBU,IAAtB,CAA2B,EAA3B,CAAP;AACD,KAFiB,CAAlB,CADqD,CAKrD;AACA;AACA;;;AAEAN,IAAAA,KAAK,CAACO,OAAN,CAAc,CAACC,KAAD,EAAQC,MAAR,KAAmB;AAC/B,UAAIC,YAAJ;;AAEA,UAAIf,MAAM,CAACgB,OAAP,CAAeF,MAAf,EAAuBG,QAA3B,EAAqC;AACnCF,QAAAA,YAAY,GAAG,uBAASF,KAAT,EAAgBb,MAAM,CAACgB,OAAP,CAAeF,MAAf,EAAuBI,KAAvC,CAAf;AACD,OAFD,MAEO;AACLH,QAAAA,YAAY,GAAG,yBAAWF,KAAX,EAAkBb,MAAM,CAACgB,OAAP,CAAeF,MAAf,EAAuBI,KAAzC,CAAf;AACD;;AAEDH,MAAAA,YAAY,CAACH,OAAb,CAAqB,CAACO,IAAD,EAAOC,MAAP,KAAkB;AACrCb,QAAAA,SAAS,CAACa,MAAD,CAAT,CAAkBN,MAAlB,IAA4BK,IAA5B;AACD,OAFD;AAGD,KAZD;AAcA,WAAOZ,SAAP;AACD,GAxBkB,CAAnB;AA0BA,SAAOC,gBAAEa,OAAF,CAAUlB,UAAV,CAAP;AACD,C","sourcesContent":["import _ from 'lodash';\nimport wrapString from './wrapString';\nimport wrapWord from './wrapWord';\n\n/**\n * @param {Array} unmappedRows\n * @param {number[]} rowHeightIndex\n * @param {Object} config\n * @returns {Array}\n */\nexport default (unmappedRows, rowHeightIndex, config) => {\n  const tableWidth = unmappedRows[0].length;\n\n  const mappedRows = unmappedRows.map((cells, index0) => {\n    const rowHeight = _.times(rowHeightIndex[index0], () => {\n      return new Array(tableWidth).fill('');\n    });\n\n    // rowHeight\n    //     [{row index within rowSaw; index2}]\n    //     [{cell index within a virtual row; index1}]\n\n    cells.forEach((value, index1) => {\n      let chunkedValue;\n\n      if (config.columns[index1].wrapWord) {\n        chunkedValue = wrapWord(value, config.columns[index1].width);\n      } else {\n        chunkedValue = wrapString(value, config.columns[index1].width);\n      }\n\n      chunkedValue.forEach((part, index2) => {\n        rowHeight[index2][index1] = part;\n      });\n    });\n\n    return rowHeight;\n  });\n\n  return _.flatten(mappedRows);\n};\n"],"file":"mapDataUsingRowHeightIndex.js"}
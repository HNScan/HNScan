extends layouts/layout

//- XXX Needs pagination
block content
  //- Leaflet is the Map API we're using
  //TODO: How to update this integrity stuff for mapbox scripts?
  link(
    rel='stylesheet',
    type='text/css',/*,
    crossorigin='',
    integrity='sha512-puBpdR0798OZvTTbP4A8Ix/l+A4dHDD0DGqYW6RQ+9jxkRFclaxxQb/SJAWZfWAkuyeQUytO7+7N4QKrDh+drA==',
    */href='https://api.tiles.mapbox.com/mapbox-gl-js/v1.2.1/mapbox-gl.css')
  .contentContainer
    .mapWrapper
      h1.peersHeader Peers
      #map
    .statsWrapper
      .card.summaryCard
        header.card-header
          h2.card-header-title Peers
        if peers.length <= 0
          .emptyStateContainer
            .emtpyStateHeader No Peers
            .emptyStateSubheader There are no peers connected to this network
        else
          each peer in peers
            .summaryCardItem(id=peer.addr.split(':')[0])
              .summaryCardBlock
                .columns
                  .column
                    .stacked
                      .stackedLabel Address
                      .stackedElement=peer.addr
                    .stacked
                      .stackedLabel Name
                      if peer.name
                        .stackedElement=peer.name
                      else
                        .stackedElement N/A
                    .stacked
                      .stackedLabel Services
                      .stackedElement=peer.services
                    .stacked
                      .stackedLabel Version
                      .stackedElement=peer.version
                  .column
                    .stacked
                      .stackedLabel Location
                      .stackedElement(id="location-" + peer.addr.split(':')[0])
                    .stacked
                      .stackedLabel Country
                      .stackedElement(id="country-" + peer.addr.split(':')[0])
                    .stacked
                      .stackedLabel Whitelisted
                      .stackedElement=peer.whitelisted ? 'Yes' : 'No'
                    .stacked
                      .stackedLabel Last Send / Last Received
                      if (peer.lastsend && peer.lastrecv)
                        .stackedElement
                          =timeAgo(peer.lastsend) + " / " + timeAgo(peer.lastrecv)
                      else
                        .stackedElement N/A
  //- Could be added to its own file
  //TODO: How to update this integrity stuff for mapbox scripts?
  script(
    src='https://api.tiles.mapbox.com/mapbox-gl-js/v1.2.1/mapbox-gl.js'/*,
    integrity='sha512-nMMmRyTVoLYqjP9hrbed9S+FzjZHW5gY1TWCHA5ckwXZBadntCNs8kEqAWdrb9O7rxbCaA4lKTIWjDXZxflOcA==',
    crossorigin=''*/
  )
  script.
    var peers = !{ JSON.stringify(peers).replace(/<\//g, '<\\/') }

    // Initialize map for peers
    /*var map = L.map("map").setView([45, -50], 1.5);
    L.tileLayer(
      "https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}",
      {
        attribution:
          'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery Â© <a href="https://www.mapbox.com/">Mapbox</a>',
        maxZoom: 18,
        id: "mapbox.streets",
        accessToken:
          "pk.eyJ1Ijoic2hhbmVqYW5uIiwiYSI6ImNqb3dqbDM2NjF1bGczb3MwYXp4dnp3c2EifQ.RKRrzIoWNE2OvVpfmSrjeQ"
      }
    ).addTo(map);*/

    var map = new mapboxgl.Map({
      "container":"map",
      "style":"mapbox://styles/earthlab/cjzobhdr311pu1cmvwovwkea9",
      "accessToken":"pk.eyJ1IjoiZWFydGhsYWIiLCJhIjoiY2p6b2JmNTRhMDB3dDNubHpyN2NnMTZ3cyJ9.2llpYjPArFZJdl9FBaqtDw",
      "zoom":1.128,
      "center":[37.8,9.03],
      hash: true,
      transformRequest: function(url, resourceType){
        if(resourceType === 'Source' && url.startsWith('http://myHost')) {
          return {
           url: url.replace('http', 'https'),
           headers: { 'my-custom-header': true},
           credentials: 'include'  // Include cookies for cross-origin requests
         }
        }
      }

    });
    map.on('load', function() {
      // Insert the layer beneath any symbol layer.
      var layers = map.getStyle().layers;
       
      var labelLayerId;
      for (var i = 0; i < layers.length; i++) {
      if (layers[i].type === 'symbol' && layers[i].layout['text-field']) {
      labelLayerId = layers[i].id;
      break;
      }
      }
       
      map.addLayer({
      'id': '3d-buildings',
      'source': 'composite',
      'source-layer': 'building',
      'filter': ['==', 'extrude', 'true'],
      'type': 'fill-extrusion',
      'minzoom': 15,
      'paint': {
      'fill-extrusion-color': '#aaa',
       
      // use an 'interpolate' expression to add a smooth transition effect to the
      // buildings as the user zooms in
      'fill-extrusion-height': [
      "interpolate", ["linear"], ["zoom"],
      15, 0,
      15.05, ["get", "height"]
      ],
      'fill-extrusion-base': [
      "interpolate", ["linear"], ["zoom"],
      15, 0,
      15.05, ["get", "min_height"]
      ],
      'fill-extrusion-opacity': .6
      }
      }, labelLayerId);

      var size = 156/* * (map.getZoom()/5)*/;
      var pulsingDot = {
        width: size,
        height: size,
        data: new Uint8Array(size * size * 4),
         
        onAdd: function() {
        var canvas = document.createElement('canvas');
        canvas.width = this.width;
        canvas.height = this.height;
        this.context = canvas.getContext('2d');
        canvas.addEventListener('click',function(err,d){
          console.log('canvas clicked');
        })
        },
         
        render: function() {
        var duration = 1000;
        var t = (performance.now() % duration) / duration;
         
        var radius = size / 2 * 0.3 * (map.getZoom()/5);
        radius = radius > size/4 ? size/4 : radius;
        var outerRadius = size / 2 * 0.7 * t + radius;
        var context = this.context;
         
        // draw outer circle
        context.clearRect(0, 0, this.width, this.height);
        context.beginPath();
        context.arc(this.width / 2, this.height / 2, outerRadius, 0, Math.PI * 2);
        context.fillStyle = 'rgba(255, 200, 200,' + (1 - t) + ')';
        context.fill();
         
        // draw inner circle
        context.beginPath();
        context.arc(this.width / 2, this.height / 2, radius, 0, Math.PI * 2);
        context.fillStyle = 'rgba(255, 200, 100, 1)';
        context.strokeStyle = 'white';
        context.lineWidth = 2 + 4 * (1 - t);
        context.fill();
        context.stroke();
         
        // update this image's data with data from the canvas
        this.data = context.getImageData(0, 0, this.width, this.height).data;
         
        // keep the map repainting
        map.triggerRepaint();
         
        // return `true` to let the map know that the image was updated
        return true;
        }
      };
      map.addImage('pulsing-dot', pulsingDot, { pixelRatio: 2 });
      requestGeolocation(peers);
    });


    

    /* Free Plan */
    function requestGeolocation(peers) {
      var url, coords, xmlHttp, ips;
      if (!peers.length) {
        return;
      }
      // extract ips from array of objects
      let idmap = {};
      //filter out 127.0.0.1 and save an API call to ipgeolocation
      ips = peers.map(function(el) {
        var retval = el.addr.split(':')[0].split('@');
        return retval.length > 1 ? retval[1] : retval[0];
      }).filter(function(ip,i){
        if(ip != '127.0.0.1'){
          idmap[Object.keys(idmap).length] = i;
        }
        return ip != '127.0.0.1';
      })
      
      //TODO: Consider caching IP's here for unique so we dont call them >1x, also consider caching/generating server side with DSTK?
      ips.map((ip,indexPosition)=>{
        xmlHttp = new XMLHttpRequest();
        url = `https://api.ipgeolocation.io/ipgeo?apiKey=0fcc7a37c67c4519a2c5e3c84dccf9c6&ip=${ip}&fields=geo`;
        // XXX This is REALLY bad...If more than 10 peers appear, this will get really slow...
        xmlHttp.open("GET", url, false);
        xmlHttp.onreadystatechange = function() {
          if (xmlHttp.readyState == 4 && xmlHttp.status == 200) {
            var response = JSON.parse(xmlHttp.responseText)
            coords = [response.latitude, response.longitude];
            addMarkers(response, coords, peers[idmap[indexPosition]]);
            applyGeolocation(response,coords,peers[idmap[indexPosition]]);
          }
        }
        xmlHttp.setRequestHeader('Content-Type', 'application/json');
        xmlHttp.send();
      })
    }
    let clickedFrom;
    let allMarkerCount = 0;
    function addMarkers(geo, coords, markerData) {
      //could be cleaner i bet
      let markerID = 'marker'+allMarkerCount;
      var layer = map.addLayer({
        "id": markerID,
        "type": "symbol",
        "source": {
        "type": "geojson",
        "data": {
          "type": "FeatureCollection",
          "features": [
              {
                "type": "Feature",
                "geometry": {
                "type": "Point",
                "coordinates": [coords[1], coords[0]],
                "meta":geo
                }
              }
            ]
          }
        },
        "layout": {
        "icon-image": "pulsing-dot"
        }
      });
      allMarkerCount++;
      
      map.on('click',markerID,function(e){
        //notate where we came from so we can zoom back out later
        clickedFrom = {
          zoom:map.getZoom(),
          center:map.getCenter(),
          bearing:map.getBearing(),
          pitch:map.getPitch()
        }
        let flyData = {
          curve:1,
          minZoom:map.getZoom(),
          speed:1.25,
          zoom:15.3,
          pitch:60,
          center:[coords[1],coords[0]]
        }
        map.flyTo(flyData);
        //now add the popup
        doPopup(coords,markerData.addr);

      });
    }
    function doPopup(coords,label){
      //add the popup with our label
      const markerHeight = 150, markerRadius = 10, linearOffset = 25;
      const popupOffsets = {
        'top': [0, 0],
        'top-left': [0,0],
        'top-right': [0,0],
        'bottom': [0, -markerHeight],
        'bottom-left': [linearOffset, (markerHeight - markerRadius + linearOffset) * -1],
        'bottom-right': [-linearOffset, (markerHeight - markerRadius + linearOffset) * -1],
        'left': [markerRadius, (markerHeight - markerRadius) * -1],
        'right': [-markerRadius, (markerHeight - markerRadius) * -1]
      };
      let popup = new mapboxgl.Popup({offset: popupOffsets, className: 'mapPopup'})
        .setLngLat([coords[1],coords[0]])
        .setHTML('<div class="resp"><textarea onclick="this.focus();this.select()" readonly="readonly">'+label+'</textarea></div>')
        .addTo(map);
      popup.on('close',(e)=>{
        //zoom back out when we close the popup
        if(typeof clickedFrom != "undefined"){
          map.flyTo({
            curve:1,
            speed:1.618,
            zoom:clickedFrom.zoom,
            pitch:clickedFrom.pitch,
            bearing:clickedFrom.bearing,
            center:clickedFrom.center
          })
        }
      });
    }
    function markerTooltip(e) {
      var el = document.getElementById(e.target.options.title);
      el.scrollIntoView();
    }

    function applyGeolocation(geo,coords,peerData) {
      var location = document.getElementById("location-" + peerData.addr.split(':')[0]);
      var country = document.getElementById("country-" + peerData.addr.split(':')[0]);
      //TODO: Generating a static link with onClick here is not ideal. Probably a much cleaner well in this pug file yay
      location.innerHTML = '<a href="#" onClick="map.flyTo({center:['+coords[1]+','+coords[0]+'],zoom:15,pitch:60}); window.scrollTo(0,0); doPopup(['+coords[0]+','+coords[1]+'],\''+peerData.addr+'\');clickedFrom = {zoom:map.getZoom(),center:map.getCenter(),bearing:map.getBearing(),pitch:map.getPitch()};">'+geo.city + ", " + geo.state_prov+'</a>';
      country.innerHTML = geo.country_name;
    }
